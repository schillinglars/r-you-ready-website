{
  "hash": "00a16e78b632c001cfac437559ed519d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Lösung 1\"\n---\n\n\n\n# Lösung - Codings Basics (Einheiten 1 und 2)\n\nBei Bedarf finden sich hier nochmal die Slides zur EH1: <iframe src=\"EH_1.html\" width=\"100%\" height=\"500px\"></iframe>\n\n## Installation R und R-Studio\n\nInstalliere R und RStudio:\n\n1.  Installation von R – neueste Version 4.5.1: <https://stat.ethz.ch/CRAN/>\n\n2.  Installation von Rstudio (Version 2025.05.1): <https://posit.co/download/rstudio-desktop/>\n\nDu weisst nicht was mit R auf sich hat? Hier ist eine Kurzerklärung: <https://methodenlehre.github.io/einfuehrung-in-R/>\n\n## Einstellungen\n\n1.  RStudio öffnen & Einstellungen vornehmen: Unter «tools» –«global options» die **unter 1.1.** beschriebenen Einstellungen vornehmen: [https://methodenlehre.github.io/einfuehrung-in-R/chapters/01-workflow.html](#0){.uri}\n\n<!-- -->\n\n2.  Neues Skript öffnen & orientieren:\n\n## Hands on: Coding Basics\n\nIm folgenden machen wir uns vertraut mit der Oberfläche von R-Studio:\n\n![](images/R_overview.png){fig-align=\"center\"}\n\n<!-- -->\n\na)  Skript für Code-Eingabe sowie Kommentare\nb)  Konsole für die Ausführung von Code -\\> Teste einfache mathematische Operation in dieser; reproduziere diese mittels Skript\nc)  Rechts oben: Environment & History\nd)  Rechts unten: Files, Plots, Packages und Help Viewer\n\n## Pakete installieren und laden\n\nTidyverse ist ein Meta-Paket, das mehrere Pakete umfasst[![https://www.tidyverse.org/](images/clipboard-602781303.png){width=\"472\"}](https://www.tidyverse.org/)\n\n1.  Pakete installieren (nur 1x notwendig) -\\> führe diesen Code in der Konsole aus\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    install.packages(\"tidyverse\")\n    ```\n    :::\n\n\n\n2.  Paket laden (innerhalb des Skriptes, bei jedem Neustart von R notwendig)\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    library(tidyverse)\n    ```\n    \n    ::: {.cell-output .cell-output-stderr}\n    \n    ```\n    ── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n    ✔ dplyr     1.1.4     ✔ readr     2.1.5\n    ✔ forcats   1.0.0     ✔ stringr   1.5.1\n    ✔ ggplot2   3.5.2     ✔ tibble    3.3.0\n    ✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n    ✔ purrr     1.1.0     \n    ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n    ✖ dplyr::filter() masks stats::filter()\n    ✖ dplyr::lag()    masks stats::lag()\n    ℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n    ```\n    \n    \n    :::\n    :::\n\n\n\nTipp: Pakete regelmässig updaten mit z.B. update.packages()\n\n### Operatoren kennenlernen\n\n1.  a\\. Nutze R als Taschenrechner\n\n    1.  `123+456`\n\n::: {.callout-note collapse=\"true\" title=\"Lösung\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n123 + 456\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 579\n```\n\n\n:::\n:::\n\n\n:::\n\n```         \n2.  `144*112`\n```\n\n::: {.callout-note collapse=\"true\" title=\"Lösung\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n144*112\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 16128\n```\n\n\n:::\n:::\n\n\n:::\n\n```         \n3.  `10/3`\n```\n\n::: {.callout-note collapse=\"true\" title=\"Lösung\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n10/3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.333333\n```\n\n\n:::\n:::\n\n\n:::\n\n```         \n4.  Quadriere 420\n```\n\n::: {.callout-note collapse=\"true\" title=\"Lösung\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n420^2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 176400\n```\n\n\n:::\n:::\n\n\n:::\n\n```         \n5.  Ziehe die Quadratwurzel aus 146 mit der Funktion `sqrt()`\n```\n\n::: {.callout-note collapse=\"true\" title=\"Lösung\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt(146)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12.08305\n```\n\n\n:::\n:::\n\n\n:::\n\n```         \n6.  Berechne den Rest der Division 10/3 mit dem Modulo Operator: `%%`\n```\n\n::: {.callout-note collapse=\"true\" title=\"Lösung\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n10 %% 3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n:::\n\n\n:::\n\n#### Arithmetische Operatoren und Funktionen in R, z.B.\n\n| Zeichen | Bedeutung                   |\n|---------|-----------------------------|\n| \\+      | Addition                    |\n| \\-      | Substraktion                |\n| \\*      | Multiplikation              |\n| /       | Division                    |\n| sqrt(x) | Quadratwurzel               |\n| abs(x)  | Betrag (absoluter Wert)     |\n| x %% y  | Modulo (x mod y) 5 %% 2 = 1 |\n| \\^      | Potenz                      |\n\n### Erste Zuweisungen/Variablen definieren\n\n1.  Weise den Wert 5 der Variable `x` zu mit dem Operator `<-`\n\n::: {.callout-note collapse=\"true\" title=\"Lösung\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 5\n```\n:::\n\n\n:::\n\n2.  Weise eine beliebige Zahl der Variable `y` hinzu und dividiere dann `x` durch `y`. Speichere dieses Ergebnis in der Variable `z.`\n\n::: {.callout-note collapse=\"true\" title=\"Lösung\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- 10 # hier könntet ihr auch jede andere Ziffer wählen\n\nz <- x / y\n```\n:::\n\n\n:::\n\n3.  Schaue dir das Ergebnis in deinem Environment an. Lass dir das Ergebnis auch in der Konsole ausgeben. Das Environment findest du oben rechts, die Konsole ist unter deinem Skript.\n\n::: {.callout-note collapse=\"true\" title=\"Lösung\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# z (hier über das # auskommentiert, da der Befehl nicht im Skript, sondern unten in der Konsole ausgeführt werden soll)\n```\n:::\n\n\n:::\n\n4.  Erstelle zwei Variablen: Eine mit deinem Vornamen und eine mit deinem Nachnamen. Solche \"character\" Variablen musst du in Anführungszeichen setzen `\"\"`\n\n::: {.callout-note collapse=\"true\" title=\"Lösung\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvorname <- \"Lars\"\nnachname <- \"Schilling\"\n```\n:::\n\n\n:::\n\n5.  Kombiniere deinen Vor- und Nachnamen zu deinem vollen Namen mittels `paste` . Speichere diese Variable als `voller_name`.\n\n::: {.callout-note collapse=\"true\" title=\"Lösung\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvoller_name <- paste(vorname, nachname)\n```\n:::\n\n\n:::\n\n### Vektoren definieren\n\n1.  Definiere einen Vektor «first_vector» mit den Zahlen 100, 80, 54, 73. Einen Vektor definiert man so: `first_vector <- c(...)`\n\n::: {.callout-note collapse=\"true\" title=\"Lösung\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfirst_vector <- c(100, 80, 54, 73)\n```\n:::\n\n\n:::\n\n2.  Wende den Befehl `boxplot()` auf deinen Vektor an\n\n::: {.callout-note collapse=\"true\" title=\"Lösung\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nboxplot(first_vector)\n```\n\n::: {.cell-output-display}\n![](loesung_1_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\n:::\n\n3.  Berechne die Summe `sum()`und den Mittelwert `mean()` von deinem Vektor\n\n::: {.callout-note collapse=\"true\" title=\"Lösung\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(first_vector)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 307\n```\n\n\n:::\n\n```{.r .cell-code}\nmean(first_vector)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 76.75\n```\n\n\n:::\n:::\n\n\n:::\n\n4.  Multipliziere deinen Vektor mit `*2`\n\n::: {.callout-note collapse=\"true\" title=\"Lösung\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfirst_vector * 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 200 160 108 146\n```\n\n\n:::\n:::\n\n\n:::\n\nDie wichtigsten Operatoren und Funktionen in R: <https://methodenlehre.github.io/einfuehrung-in-R/chapters/02-R-language.html>\n\n#### Statistische Funktionen, die man auf Vektoren anwenden kann, z.B.\n\n| Funktion              | Bedeutung                 |\n|-----------------------|---------------------------|\n| mean(x, na.rm =FALSE) | Mittelwert                |\n| sd(x)                 | Standardabweichung        |\n| var(x)                | Varianz                   |\n| median(x)             | Median                    |\n| sum(x)                | Summe                     |\n| min(x)                | Minimalwert               |\n| max(x)                | Maximalwert               |\n| range(x)              | Minimal - und Maximalwert |\n\n### Logische Operatoren\n\n1.  Teste ob die Zahl 5 größer als 2 ist –\\> TRUE or FALSE?\n\n::: {.callout-note collapse=\"true\" title=\"Lösung\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n5 > 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\nTRUE, 5 ist grösser als 2.\n:::\n\n2.  Teste ob 6 ungleich 8 ist –\\> TRUE or FALSE?\n\n::: {.callout-note collapse=\"true\" title=\"Lösung\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n6!=8\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\nTRUE, 6 und 8 sind ungleich.\n:::\n\n3.  Subtrahiere 80 von 50 und speichere das Ergebnis in einer Variable namens «diff_score».\n\n::: {.callout-note collapse=\"true\" title=\"Lösung\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiff_score <- 80 - 50\n```\n:::\n\n\n:::\n\n4.  Berechne mit `abs()` den absoluten Wert von «diff_score» lassen dir diesen mit `print(diff_score)` in der Konsole ausgeben.\n\n::: {.callout-note collapse=\"true\" title=\"Lösung\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiff_score_abs <- abs(diff_score)\n\n# print(diff_score_abs) (hier erneut mit # auskommentiert, da der Befehl nicht im Skript, sondern in der Console ausgeführt werden soll)\n```\n:::\n\n\n:::\n\n#### Logische Operatoren, z.B.\n\n| Zeichen | Bedeutung      |\n|---------|----------------|\n| ==      | gleich         |\n| !=      | ungleich       |\n| \\>      | grösser        |\n| \\>=     | grösser gleich |\n| \\<      | kleiner        |\n| \\<=     | kleiner gleich |\n| \\|      | Logisches Oder |\n| &       | Logisches Und  |\n\n## Nachvollziehbarkeit von Code\n\n### Kommentare\n\nInformative Kommentare im Code sind elementar für die Nachvollziehbarkeit.\n\n1.  Schreibe einen Kommentar indem du ein `#` verwendest.\n\n::: {.callout-note collapse=\"true\" title=\"Lösung\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Hier ein Beipsiel für einen Kommentar, wie auch schon weiter oben mehrmals verwendet um die Lösungen davon zu hindern ausgeführt zu werden.\n```\n:::\n\n\n:::\n\n2.  Code der nach einem `#` steht wird nicht ausgeführt. Setze ein `#` vor eine Codezeile und führe sie aus und beobachte was passiert.\n\n::: {.callout-note collapse=\"true\" title=\"Lösung\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 1 + 2\n```\n:::\n\n\n:::\n\n### Benennung von Variablen\n\nEs gibt verschiedene Konventionen wie man Variablen bennen kann:\n\n<https://methodenlehre.github.io/einfuehrung-in-R/chapters/02-R-language.html#variablennamen>\n\n1.  Definiere eine neue Variable nach snake_case\n\n::: {.callout-note collapse=\"true\" title=\"Lösung\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nneue_variable <- \"snake_case\"\n```\n:::\n\n\n:::\n\n2.  Definiere eine zweite Variable nach CamelCase\n\n::: {.callout-note collapse=\"true\" title=\"Lösung\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nneueVariable <- \"CamelCase\"\n```\n:::\n\n\n:::\n\n## Für fortgeschrittene R-Nutzer:innen\n\n1.  Speichere die beiden höchsten Werte aus «first_vector» in einer neuen Variable ab.\n\n::: {.callout-note collapse=\"true\" title=\"Lösung\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntop_two <- sort(first_vector, decreasing = TRUE)[1:2]\n```\n:::\n\n\n:::\n\n2.  Erstelle einen Vektor mit Werten von 0-1000 in 10er Schritten.\n\n::: {.callout-note collapse=\"true\" title=\"Lösung\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec_seq <- seq(from = 1, to = 1000, by = 10)\n```\n:::\n\n\n:::\n\n3.  Ziehe zufällig eine Zahl aus diesem Vektor\n\n::: {.callout-note collapse=\"true\" title=\"Lösung\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsample(vec_seq, 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 141\n```\n\n\n:::\n:::\n\n\n:::\n\n4.  Generiere einen Vektor, der aus 50 Wiederholungen der Zahl 3 besteht.\n\n::: {.callout-note collapse=\"true\" title=\"Lösung\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_vector <- rep(3, times = 50)\n```\n:::\n\n\n:::\n\nTipps zu diesen Aufgaben findest du bei Bedarf hier: <https://methodenlehre.github.io/einfuehrung-in-R/chapters/02-R-language.html> (Kapitel 2.1)\n\n## Datentypen\n\n1.  **numeric vectors:** werden in integer (ganze Zahlen) und double (reelle Zahlen) unterteilt, z.B.\n\n    `numerical_vector <- c(1, 2.5, 4)`\n\n2.  **character vectors:** bestehen aus Zeichen, welche von Anführungszeichen umgeben werden, z.B.\n\n    `text_vector <- c(\"Hello\", \"World\")`\n\n3.  **logical vectors:** Elemente dieses Typs können nur 3 Werte annehmen: TRUE, FALSE oder NA\n\n    `log_vector <- c(TRUE, FALSE, TRUE)`\n\nVektoren müssen aus denselbsten Elementen bestehen, d.h. z.B. numeric und character können nicht gemischt werden. Vektoren werden meist mit `c()` erstellt.\n\n# Zusätzliche Übungen:\n\nℹ️ **Hinweis:** Hilfestellungen zu den Übungen findest du [hier](https://methodenlehre.github.io/einfuehrung-in-R/chapters/02-R-language.html#datentypen).\n\nNicht alle benötigten Funktionen sind explizit erwähnt. Nutze bei Bedarf eine Suchmaschine, um passende Befehle zu finden.\n\n**Überprüfen von Datentypen – palmerpenguins**\n\nLade den öffentlich in R verfügbaren Datensatz *palmerpenguins* mit den folgenden Befehlen:\n\n``` r\ninstall.packages(\"palmerpenguins\")   # nur einmal nötig \n```\n\n::: {.callout-note collapse=\"true\" title=\"Lösung\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# install.packages(\"palmerpenguins\")   # nur einmal nötig # führe diesen Code in der Console aus\n```\n:::\n\n\n:::\n\n``` r\nlibrary(palmerpenguins) \nmy_penguins <- penguins \n```\n\n::: {.callout-note collapse=\"true\" title=\"Lösung\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(palmerpenguins) \n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttache Paket: 'palmerpenguins'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nDie folgenden Objekte sind maskiert von 'package:datasets':\n\n    penguins, penguins_raw\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_penguins <- penguins\n```\n:::\n\n\n:::\n\n### Datensatz inspizieren\n\n-   Wie viele Variablen (Spalten) sind enthalten?\n\n::: {.callout-note collapse=\"true\" title=\"Lösung\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nncol(my_penguins)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 8\n```\n\n\n:::\n:::\n\n\n:::\n\n-   Wie viele Beobachtungen (Zeilen)?\n\n::: {.callout-note collapse=\"true\" title=\"Lösung\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnrow(my_penguins)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 344\n```\n\n\n:::\n:::\n\n\n:::\n\n### Überblick über den Datensatz\n\nNutze verschiedene Befehle und vergleiche die Ergebnisse:\n\nVerwende die Hilfefunktion `?funktionsname` um dir zeigen zu lassen welche Argumente die Funktionen benötigen.\n\n-   `head()`\n\n::: {.callout-note collapse=\"true\" title=\"Lösung\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?head() # um die Hilfeseite zu öffnen\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nstarte den http Server für die Hilfe fertig\n```\n\n\n:::\n\n```{.r .cell-code}\nhead(my_penguins)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 8\n  species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  <fct>   <fct>              <dbl>         <dbl>             <int>       <int>\n1 Adelie  Torgersen           39.1          18.7               181        3750\n2 Adelie  Torgersen           39.5          17.4               186        3800\n3 Adelie  Torgersen           40.3          18                 195        3250\n4 Adelie  Torgersen           NA            NA                  NA          NA\n5 Adelie  Torgersen           36.7          19.3               193        3450\n6 Adelie  Torgersen           39.3          20.6               190        3650\n# ℹ 2 more variables: sex <fct>, year <int>\n```\n\n\n:::\n:::\n\n\n:::\n\n-   `glimpse()`\n\n::: {.callout-note collapse=\"true\" title=\"Lösung\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?glimpse() # um die Hilfeseite zu öffnen\nglimpse(my_penguins)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 344\nColumns: 8\n$ species           <fct> Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adel…\n$ island            <fct> Torgersen, Torgersen, Torgersen, Torgersen, Torgerse…\n$ bill_length_mm    <dbl> 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, …\n$ bill_depth_mm     <dbl> 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, …\n$ flipper_length_mm <int> 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186…\n$ body_mass_g       <int> 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n$ sex               <fct> male, female, female, NA, female, male, female, male…\n$ year              <int> 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\n```\n\n\n:::\n:::\n\n\n:::\n\n-   `str()`\n\n::: {.callout-note collapse=\"true\" title=\"Lösung\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?str() # um die Hilfeseite zu öffnen\nstr(my_penguins)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntibble [344 × 8] (S3: tbl_df/tbl/data.frame)\n $ species          : Factor w/ 3 levels \"Adelie\",\"Chinstrap\",..: 1 1 1 1 1 1 1 1 1 1 ...\n $ island           : Factor w/ 3 levels \"Biscoe\",\"Dream\",..: 3 3 3 3 3 3 3 3 3 3 ...\n $ bill_length_mm   : num [1:344] 39.1 39.5 40.3 NA 36.7 39.3 38.9 39.2 34.1 42 ...\n $ bill_depth_mm    : num [1:344] 18.7 17.4 18 NA 19.3 20.6 17.8 19.6 18.1 20.2 ...\n $ flipper_length_mm: int [1:344] 181 186 195 NA 193 190 181 195 193 190 ...\n $ body_mass_g      : int [1:344] 3750 3800 3250 NA 3450 3650 3625 4675 3475 4250 ...\n $ sex              : Factor w/ 2 levels \"female\",\"male\": 2 1 1 NA 1 2 1 2 NA NA ...\n $ year             : int [1:344] 2007 2007 2007 2007 2007 2007 2007 2007 2007 2007 ...\n```\n\n\n:::\n:::\n\n\n:::\n\n-   `penguins`\n\n::: {.callout-note collapse=\"true\" title=\"Lösung\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ist keine Funktion sondern ein Datensatz und daher gibt es hierfür auch keine Hilfeseite\npenguins\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   <fct>   <fct>              <dbl>         <dbl>             <int>       <int>\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ 334 more rows\n# ℹ 2 more variables: sex <fct>, year <int>\n```\n\n\n:::\n:::\n\n\n:::\n\n-   `summary()`\n\n::: {.callout-note collapse=\"true\" title=\"Lösung\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?summary() # um die Hilfeseite zu öffnen\nsummary(my_penguins)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      species          island    bill_length_mm  bill_depth_mm  \n Adelie   :152   Biscoe   :168   Min.   :32.10   Min.   :13.10  \n Chinstrap: 68   Dream    :124   1st Qu.:39.23   1st Qu.:15.60  \n Gentoo   :124   Torgersen: 52   Median :44.45   Median :17.30  \n                                 Mean   :43.92   Mean   :17.15  \n                                 3rd Qu.:48.50   3rd Qu.:18.70  \n                                 Max.   :59.60   Max.   :21.50  \n                                 NA's   :2       NA's   :2      \n flipper_length_mm  body_mass_g       sex           year     \n Min.   :172.0     Min.   :2700   female:165   Min.   :2007  \n 1st Qu.:190.0     1st Qu.:3550   male  :168   1st Qu.:2007  \n Median :197.0     Median :4050   NA's  : 11   Median :2008  \n Mean   :200.9     Mean   :4202                Mean   :2008  \n 3rd Qu.:213.0     3rd Qu.:4750                3rd Qu.:2009  \n Max.   :231.0     Max.   :6300                Max.   :2009  \n NA's   :2         NA's   :2                                 \n```\n\n\n:::\n:::\n\n\n:::\n\n👉 Was sind die Unterschiede zwischen den Befehlen?\n\nAlle der Befehle sind dafür geeignet einen ersten schnellen Überblick über den Datensatz zu erhalten. `head()` gibt die ersten paar (Standardmässig 6) Zeilen des Datensatzes aus. `glimpse()` gibt für jede Spalte den Namen, Typ und ihren ersten Wert aus. `str()` gibt einen Überblick über die Dimensionen des Datensatzes, wie Anzahl an Spalten, Anzahl an Zeilen und über die Datentypen. `summary()` gibt eine statistische Zusammenfassung des Datensatzes, wie beispielsweise bei numerischen Variablen den minimalen Wert, maximalen Wert, Median und Mean oder bei faktoriellen Variablen die Anzahl an Faktorstufen und ihrer entsprechenden Häufigkeit. Mit `penguins` allein wird einfach das entsprechende Objekt aufgerufen (hier handelt es sich nicht um eine Funktion).\n\n### Datentypen überprüfen\n\n-   Welchen Datentyp haben diese Variablen?\n\n    -   `island`\n\n::: {.callout-note collapse=\"true\" title=\"Lösung\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(my_penguins$island)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"factor\"\n```\n\n\n:::\n:::\n\n\n:::\n\n`island`hat den Datentyp *factor*.\n\n```         \n-   `body_mass_g`\n```\n\n::: {.callout-note collapse=\"true\" title=\"Lösung\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(my_penguins$body_mass_g)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n:::\n\n\n:::\n\n`body_mass_g`hat den Datentyp *integer*.\n\n```         \n-   `species`\n```\n\n::: {.callout-note collapse=\"true\" title=\"Lösung\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(my_penguins$species)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"factor\"\n```\n\n\n:::\n:::\n\n\n:::\n\n`species` hat den Datentyp *factor*.\n\n```         \nTipp: Googeln\n```\n\n::: {.callout-note collapse=\"true\" title=\"Vertiefung\"}\nIhr hättet die Datentypen aus den vorherigen Aufgaben auch mit folgendem Code lösen können:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(my_penguins$island)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(my_penguins$body_mass_g)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(my_penguins$species)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n:::\n\n\n\nWie die Funktion `class()` lässt sich auch mit der Funktion `typeof()` der Datentyp einer Spalte abfragen. Allerdings unterscheiden sich die beiden Funktionen darin, **welche Information sie liefern**, und dementsprechend auch in ihren Ausgaben.\n\nDie Funktion `class()` gibt an, **welcher Klasse ein Objekt in R zugeordnet ist** – also, wie es sich in Funktionen und Methoden verhalten soll. Beispiele für Klassen sind `numeric`, `character`, `factor` oder `data.frame`.\n\nDie Funktion `typeof()` hingegen zeigt an, **welcher grundlegende Datentyp intern im Speicher verwendet wird**, um das Objekt zu repräsentieren. Für Objekte vom Typ `numeric` oder `character` liefern `class()` und `typeof()` in der Regel identische Ergebnisse. Bei einem `factor`-Objekt unterscheiden sich die Ausgaben jedoch: `class()` gibt `\"factor\"` zurück, während `typeof()` `\"integer\"` liefert, da Faktoren intern als Ganzzahlen mit zugehörigen Levels gespeichert werden. Wir empfehlen dir daher die Funktion `class` zu verwenden, da wir uns im Rahmen des Seminars dafür interessieren welcher Klasse ein Objekt in R zugeordnet ist. [Hier](https://mgimond.github.io/ES218/data_objects.html#:~:text=An%20R%20object's%20data%20type,not%20distinguish%20integers%20from%20doubles.) kannst du noch eine genauere Erklärung dazu finden welche grundlegende Datentypen im internen Speicher verwendet werden und wo der Unterschied herkommt.\n:::\n\n### Logisches Abfragen\n\n-   Überprüfe, ob `bill_depth_mm` ein numerischer Vektor ist.\n\n::: {.callout-note collapse=\"true\" title=\"Lösung\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.numeric(my_penguins$bill_depth_mm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n:::\n\n-   Gib die Antwort als logischen Wert aus (`TRUE` oder `FALSE`) und speichere sie in einer neuen Variable.\n\n::: {.callout-note collapse=\"true\" title=\"Lösung\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspecies_numeric <- is.numeric(my_penguins$bill_depth_mm) # der genaue Name der Variable sollte im snake_case geschrieben sein und über den Inhalt informieren. Ansonsten ist er arbiträr\n```\n:::\n\n\n:::\n\n-   Prüfe anschließend, ob diese neue Variable selbst ein logischer Vektor ist.\n\n::: {.callout-note collapse=\"true\" title=\"Lösung\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.logical(species_numeric) # hier müsst ihr als Argument natürlich den von euch eben vergebenen Variablennamen auswählen\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n:::\n\n# Am Ende deiner Übungen - vergiss nicht dein Skript abzuspeichern! :-)\n\nGib diesem einem Namen, der Maschinen und Mensch-lesbar ist, siehe Kapitel 6.1.3 hier: <https://r4ds.hadley.nz/workflow-scripts>\n",
    "supporting": [
      "loesung_1_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}